name: Deploy to DEVELOPMENT EKS

on:
  push:
    branches:
      - main

env:
  ECR_REPOSITORY: repo-dev
  EKS_CLUSTER_NAME: eks-cluster-123 
  AWS_REGION: us-west-2

jobs:
  build:
    name: Deployment
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v2
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Read Current Version from VERSION file
        id: read-version
        run: echo "::set-output name=version::$(cat VERSION)"

      - name: Determine semantic version
        id: determine-version
        run: |
          # Extract commit message from the latest commit
          COMMIT_MESSAGE=$(git log -1 --pretty=%B)

          # Determine the version type based on the commit message
          if echo "$COMMIT_MESSAGE" | grep -q 'BREAKING CHANGE'; then
            echo "::set-output name=version::major"
          elif echo "$COMMIT_MESSAGE" | grep -q 'feat'; then
            echo "::set-output name=version::minor"
          else
            echo "::set-output name=version::patch"
          fi

      - name: Determine version update
        id: determine-update
        run: |
          VERSION=$(echo ${{ steps.determine-version.outputs.version }})
          if [ "$VERSION" = "major" ]; then
            echo "::set-output name=update::major"
          elif [ "$VERSION" = "minor" ]; then
            echo "::set-output name=update::minor"
          else
            echo "::set-output name=update::patch"
          fi

      - name: Update Version
        id: update-version
        run: |
          CURRENT_VERSION=$(echo ${{ steps.read-version.outputs.version }})
          VERSION_TYPE=$(echo ${{ steps.determine-version.outputs.version }})

          # Parse the version numbers
          IFS='.' read -r -a VERSION_ARRAY <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_ARRAY[0]}
          MINOR=${VERSION_ARRAY[1]}
          PATCH=${VERSION_ARRAY[2]}

          # Update version numbers based on the release type
          if [ "$VERSION_TYPE" = "major" ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$VERSION_TYPE" = "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi

          # Generate the new version
          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "$NEW_VERSION" > VERSION
          echo "::set-output name=new_version::$NEW_VERSION"

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          VERSION=$(echo ${{ steps.update-version.outputs.new_version }})
          UPDATE=$(echo ${{ steps.determine-update.outputs.update }})

          IMAGE_TAG="${VERSION}"
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f Application/Dockerfile .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

      # - name: Retrieve Latest Release ID
      #   id: get-release-id
      #   run: |
      #     RELEASE_ID=$(curl -sL https://api.github.com/repos/rinshad1/nodejs-test-application/releases/latest | grep -oP '"id": \K[0-9]+')
      #     echo "::set-output name=release-id::$RELEASE_ID"
        
      # - name: Update Release Tag
      #   run: |
      #     RELEASE_ID=${{ steps.get-release-id.outputs.release-id }}
      #     NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
      #     curl -X PATCH -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
      #       -d '{"tag_name": "'"$NEW_TAG"'"}' \
      #       "https://api.github.com/repos/rinshad1/nodejs-test-application/releases/$RELEASE_ID"
                  
      # Continue with the remaining steps as per your workflow
