name: sample Test

on:
  push:
    branches:
      - main

env:
  ECR_REPOSITORY: repo-dev
  EKS_CLUSTER_NAME: eks-cluster-123 
  AWS_REGION: us-west-2

jobs:
  build:
    name: Deployment
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v2

      - name: Semantic Releasify
      # You may pin to the exact commit or the version.
      # uses: d3p1/semantic-releasify@235a884f798d7f845f24cd192c2d67fb08315efd
        uses: d3p1/semantic-releasify@v1.1.0
        with:
        # The branch on which release should happen
          branch: main
        # The Git tag format used by semantic-release to identify releases
          tag-format: "${version}"
      - run: echo "version is  ${version}"  
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}  
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1


      
      

            
      # - name: Read Current Version from ECR repo images
      #   id: read-version
      #   run: |
      #     # Get the latest image tag from the ECR repository
      #     VERSION=$(aws ecr describe-images --repository-name $ECR_REPOSITORY --region $AWS_REGION --query 'sort_by(imageDetails,& imagePushedAt)[-1].imageTags[0]' --output text)
      #     echo "::set-output name=version::$VERSION"
      #   env:
      #     AWS_REGION: ${{ env.AWS_REGION }}
      #     ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
      
      # - name: Determine semantic version
      #   id: determine-version
      #   run: |
      #     # Extract commit message from the latest commit
      #     COMMIT_MESSAGE=$(git log -1 --pretty=%B)

      #     # Determine the version type based on the commit message
      #     if echo "$COMMIT_MESSAGE" | grep -q 'BREAKING CHANGE'; then
      #       echo "::set-output name=version::major"
      #     elif echo "$COMMIT_MESSAGE" | grep -q 'feat'; then
      #       echo "::set-output name=version::minor"
      #     else
      #       echo "::set-output name=version::patch"
      #     fi

      # - name: Determine version update
      #   id: determine-update
      #   run: |
      #     VERSION=$(echo ${{ steps.determine-version.outputs.version }})
      #     if [ "$VERSION" = "major" ]; then
      #       echo "::set-output name=update::major"
      #     elif [ "$VERSION" = "minor" ]; then
      #       echo "::set-output name=update::minor"
      #     else
      #       echo "::set-output name=update::patch"
      #     fi

      # - name: Update Version
      #   id: update-version
      #   run: |
      #     CURRENT_VERSION=$(echo ${{ steps.read-version.outputs.version }})
      #     VERSION_TYPE=$(echo ${{ steps.determine-version.outputs.version }})

      #     # Parse the version numbers
      #     IFS='.' read -r -a VERSION_ARRAY <<< "$CURRENT_VERSION"
      #     MAJOR=${VERSION_ARRAY[0]}
      #     MINOR=${VERSION_ARRAY[1]}
      #     PATCH=${VERSION_ARRAY[2]}

      #     # Update version numbers based on the release type
      #     if [ "$VERSION_TYPE" = "major" ]; then
      #       MAJOR=$((MAJOR + 1))
      #       MINOR=0
      #       PATCH=0
      #     elif [ "$VERSION_TYPE" = "minor" ]; then
      #       MINOR=$((MINOR + 1))
      #       PATCH=0
      #     else
      #       PATCH=$((PATCH + 1))
      #     fi

      #     # Generate the new version
      #     NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
      #     echo "$NEW_VERSION" > VERSION
      #     echo "::set-output name=new_version::$NEW_VERSION"

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          VERSION=$(echo ${{ steps.update-version.outputs.new_version }})
          UPDATE=$(echo ${{ steps.determine-update.outputs.update }})

          IMAGE_TAG="${VERSION}"
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f Application/Dockerfile .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
##