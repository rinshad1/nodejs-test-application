name: Deploy to DEVELOPMENT EKS

on:
  push:
    branches:
      - main

env:
  ECR_REPOSITORY: repo-dev
  EKS_CLUSTER_NAME: eks-cluster-123 
  AWS_REGION: us-west-2

jobs:
  build:
    name: Deployment
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v2
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Determine semantic version
        id: determine-version
        run: |
          # Extract commit message from the latest commit
          COMMIT_MESSAGE=$(git log -1 --pretty=%B)

          # Determine the version type based on the commit message
          if echo "$COMMIT_MESSAGE" | grep -q 'BREAKING CHANGE'; then
            echo "::set-output name=version::major"
          elif echo "$COMMIT_MESSAGE" | grep -q 'feat'; then
            echo "::set-output name=version::minor"
          else
            echo "::set-output name=version::patch"
          fi

      - name: Determine version update
        id: determine-update
        run: |
          VERSION=$(echo ${{ steps.determine-version.outputs.version }})
          if [ "$VERSION" = "major" ]; then
            echo "::set-output name=update::major"
          elif [ "$VERSION" = "minor" ]; then
            echo "::set-output name=update::minor"
          else
            echo "::set-output name=update::patch"
          fi

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          VERSION=$(echo ${{ steps.determine-version.outputs.version }})
          UPDATE=$(echo ${{ steps.determine-update.outputs.update }})

          # Determine the current version
          #CURRENT_VERSION=0.0.0
          CURRENT_VERSION=$(curl -sL https://api.github.com/repos/rinshad1/nodejs-test-application/releases/latest | grep -oP '"tag_name": "\K(.*)(?=")')
          echo "$CURRENT_VERSION"
          # Parse the version numbers
          IFS='.' read -r -a VERSION_ARRAY <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_ARRAY[0]}
          MINOR=${VERSION_ARRAY[1]}
          PATCH=${VERSION_ARRAY[2]}

          # Update version numbers based on the release type
          if [ "$UPDATE" = "major" ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$UPDATE" = "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi

          # Generate the new version tag
          IMAGE_TAG="${MAJOR}.${MINOR}.${PATCH}"
          echo $ECR_REGISTRY
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f Application/Dockerfile .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
      

      - name: Retrieve Latest Release ID
        id: get-release-id
        run: |
              RELEASE_ID=$(curl -sL https://api.github.com/repos/rinshad1/nodejs-test-application/releases/latest | grep -oP '"id": \K[0-9]+')
              echo "::set-output name=release-id::$RELEASE_ID"
            
      - name: Update Release Tag
        run: |
              RELEASE_ID=${{ steps.get-release-id.outputs.release-id }}
              NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
              curl -X PATCH -H "Authorization: token ${{ secrets.IGITHUB_TOKEN }}" \
                -d '{"tag_name": "'"$NEW_TAG"'"}' \
                "https://api.github.com/repos/rinshad1/nodejs-test-application/releases/$RELEASE_ID"
        
                  
      # Continue with the remaining steps as per your workflow
###########